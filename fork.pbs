#PBS -N forkVER
#PBS -A ACF-UTK0011
#PBS -l feature=MACHINE
#PBS -l partition=MACHINE
#PBS -l nodes=1,walltime=23:50:00
#PBS -j oe
#PBS -S /bin/bash
LD_LIBRARY_PATH=$HOME/lib:$HOME/lib64:$LD_LIBRARY_PATH
c=/lustre/haven/user/audris/gz
cd $c


machine=MACHINE
maxM=5000
[[ $machine == monster ]] && maxM=30000
[[ $machine == rho ]] && maxM=900
[[ $machine == sigma ]] && maxM=2900



ver=VER
if test 'a' = 'a'; then

for j in {0..31}
do zcat c2pFull$ver$j.s | perl ~/lookup/ghfork0.perl 2 2> noForkI${ver}.$j | gzip > c2PFull$ver$j.s &
done
wait
echo c2PFull$ver$j.s

fi
if test 'a' = 'b'; then

zcat C2PFull${ver}0-31.s | perl $HOME/lookup/connectExportPreNoExclude.perl | gzip > C2PFull${ver}0-31.p2p
zcat C2PFull${ver}0-31.p2p | perl ~/lookup/connectExportPre1.perl C2PFull${ver}0-31
zcat C2PFull${ver}0-31.versions |  perl $HOME/lookup/connectPrune.perl |gzip > C2PFull${ver}0-31.versions.gz

fi
if test 'a' = 'a'; then

for j in {0..31}
do zcat c2PFull$ver$j.s | uniq | lsort ${maxM}M -t\; -k1,2 -u | gzip > c2PFull$ver$j.ss &
done
wait
echo c2PFull$ver$j.ss

for j in {0..31}
do zcat c2PFull$ver$j.ss | perl $HOME/lookup/connectExportPreNoExclude.perl | gzip > c2PFull$ver$j.p2p & 
done
wait
echo c2PFull$ver$j.p2p

for j in {0..31}
do zcat c2PFull$ver$j.p2p | perl ~/lookup/connectExportPre1.perl c2PFull$ver$j &
done
wait
echo c2PFull$ver$j.names

for j in {0..31}
do zcat c2PFull$ver$j.versions |  perl $HOME/lookup/connectPrune.perl |gzip > c2PFull$ver$j.versions.gz &
done
wait
echo c2PFull$ver$j.versions.gz 

#now use R for community detection?
fi
if test 'a' = 'b'; then

for j in {0..31}
do zcat c2PFull$ver$j.ss | perl ~/lookup/mp.perl 0 c2pcFullQ.map.$j.gz | uniq | gzip > C2PFull$ver$j.gz &
done
wait
echo C2PFull$ver$j.gz

for j in {0..31}
do zcat C2PFullQ$j.gz | uniq | perl $HOME/lookup/splitSec.perl C2PFullQ$j. 32 &
done
wait
echo C2PFullQ$j.

for j in {0..31}
do for k in {0..31}
  do zcat C2PFullQ$j.$k.gz | lsort ${maxM}M -t\; -k1,2 -u | gzip > C2PFullQ$j.$k.s &
  done
  wait
  echo C2PFullQ$j.$k.s
done

for j in {0..31}
do str="$HOME/bin/lsort ${maxM}M -t\; -k1b,2 --merge -u"
  for k in {0..31}; do str="$str <(zcat C2PFullQ$k.$j.s)"; done
  eval $str | gzip > C2PFullQ$j.s &
done
wait
echo C2PFullQ$j.s 

for j in {0..31}
do zcat C2PFullQ$j.gz | uniq | lsort ${maxM}M -t\; -k1,2 -u | gzip > C2PFullQ$j.s &
done
wait
echo C2PFullQ$j.s

for j in {0..31}
do zcat C2PFull$ver$j.s | perl $HOME/lookup/connectExportPreNoExclude.perl | gzip > C2PFull$ver$j.p2p &
done
wait
echo C2PFull$ver$j.p2p
  
for j in {0..31}
do zcat C2PFull$ver$j.p2p | perl ~/lookup/connectExportPre1.perl C2PFull$ver$j &
done
wait
echo C2PFull$ver$j.names

for j in {0..31}
do zcat C2PFull$ver$j.versions |  perl $HOME/lookup/connectPrune.perl |gzip > C2PFull$ver$j.versions.gz &
done
wait
echo C2PFull$ver$j.versions.gz

fi
if test 'a' = 'b'; then

for j in {0..31}
do zcat c2pFull${ver}.$j.s | perl $HOME/lookup/connectExportPreNoExclude.perl | gzip > c2pFull$ver$j.p2p &
done
wait
echo c2pFull$ver$j.p2p

fi
if test 'a' = 'a'; then

for j in {0..31}
do zcat c2pFull$ver$j.p2p | perl $HOME/lookup/connectExportSrtAdj.perl c2pFull$ver$j &
done
wait
echo c2pFull$ver$j

for j in {0..31}
do zcat c2pFull$ver$j.versions |  perl $HOME/lookup/connectPrune.perl |gzip > c2pFull$ver$j.versions1 &
done
wait
echo c2pFull$ver$j.versions1

for j in {0..31}
do (zcat c2pFull$ver$j.versions1| $HOME/bin/connect | gzip > c2pFull$ver$j.clones; perl $HOME/lookup/connectImport.perl c2pFull$ver$j | gzip > c2pFull$ver$j.map) &
done 
wait
echo c2pFull$ver$j.map

zcat c2pFull$ver*.map | perl $HOME/lookup/connectExportPre1.perl c2pFull$ver
echo c2pFull$ver


zcat c2pFull$ver.versions |  $HOME/bin/connect | gzip > c2pFull$ver.clones
echo c2pFull$ver.clones

perl $HOME/lookup/connectImport.perl c2pFull$ver | gzip > c2pFull$ver.forks
echo c2pFull$ver.forks
zcat c2pFull$ver.forks | $HOME/bin/lsort ${maxM}M -t\; -k1b,1 | gzip > c2pFull$ver.forks.s
echo c2pFull$ver.forks.s


for i in {0..31}; do zcat p$ver.$i.s; done | awk '{print $1";"$1}' | perl $HOME/lookup/mp.perl 0 c2pFull$ver.forks | gzip > p$ver.map
echo p$ver.map

fi

